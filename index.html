<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Where's My Antipode?</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <span id="title">Where's My Antipode?</span>
    <nav><a href="other-sites/addresses.html">Other Sites by Jdeseech</a></nav>
  </header>
  <div id="globe-container">
    <div id="globeViz"></div>
    <div id="info">Click anywhere on the globe to find the antipodal location.</div>
    <form id="coord-form">
      <input type="number" id="lat-input" placeholder="Latitude" step="any" required />
      <input type="number" id="lng-input" placeholder="Longitude" step="any" required />
      <button type="submit">Go</button>
    </form>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.153.0';
    import Globe   from 'https://esm.sh/globe.gl@2.41.1';

    // Globe 초기화
    const world = Globe()(document.getElementById('globeViz'))
      .globeImageUrl('https://unpkg.com/three-globe/example/img/earth-night.jpg')
      .pointOfView({ lat: 0, lng: 0, altitude: 2 });

    // 마커와 선을 담을 그룹
    const markerGroup = new THREE.Group();
    world.scene().add(markerGroup);
    const lineGroup   = new THREE.Group();
    world.scene().add(lineGroup);
    const markers     = [];

    // 마커 생성 함수
    function createMarker(color) {
      const mat  = new THREE.MeshBasicMaterial({ color });
      const cone = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 8), mat);
      cone.position.y = -0.25;
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), mat);
      const grp = new THREE.Group();
      grp.add(cone);
      grp.add(sphere);
      return grp;
    }

    // (lat,lng,altitude) → {x,y,z} 변환 (three-globe 내장) :contentReference[oaicite:0]{index=0}
    function latLngToVector3(lat, lng, altitude) {
      return world.getCoords(lat, lng, altitude);
    }

    // 마커 위치 설정
    function setMarkerPosition(marker, lat, lng, altitude) {
      const { x, y, z } = world.getCoords(lat, lng, altitude);
      marker.position.set(x, y, z);
      marker.lookAt(0, 0, 0);
    }

    // 안티포드 선 생성
    function createAntipodeLine(lat, lng, antiLat, antiLng) {
      const start = latLngToVector3(lat, lng, 1.01);
      const end   = latLngToVector3(antiLat, antiLng, 1.01);
      const pts   = [
        new THREE.Vector3(start.x, start.y, start.z),
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(end.x, end.y, end.z)
      ];
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const mat  = new THREE.LineDashedMaterial({
        color: 0xffffff,
        dashSize: 2,
        gapSize: 1,
        opacity: 0.5,
        transparent: true
      });
      const line = new THREE.Line(geom, mat);
      line.computeLineDistances();
      return line;
    }

    function clearMarkers() {
      markerGroup.clear();
      markers.length = 0;
    }
    function clearLines() {
      lineGroup.clear();
    }

    // 마커 애니메이션
    function animateMarkers() {
      markers.forEach(m => {
        m.userData.t += 0.02;
        const alt = 1.02 + 0.02 * Math.sin(m.userData.t);
        setMarkerPosition(m, m.userData.lat, m.userData.lng, alt);
        m.rotateZ(0.05);
      });
      requestAnimationFrame(animateMarkers);
    }
    animateMarkers();

    const info     = document.getElementById('info');
    const form     = document.getElementById('coord-form');
    const latInput = document.getElementById('lat-input');
    const lngInput = document.getElementById('lng-input');

    // 좌표 → 지명 (OSM)
    function reverseGeocode(lat, lng) {
      return fetch(
        `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`
      )
        .then(res => res.json())
        .then(data => {
          const addr = data.address || {};
          return addr.city || addr.town || addr.village || addr.country || 'the ocean';
        })
        .catch(() => 'Unknown location');
    }

    // 안티포드 표시
    function showAntipode(lat, lng) {
      const antiLat = -lat;
      // 경도 반전 계산
      const antiLng = lng >= 0 ? lng - 180 : lng + 180;

      Promise.all([reverseGeocode(lat, lng), reverseGeocode(antiLat, antiLng)])
        .then(([clickedLoc, antipodeLoc]) => {
          clearMarkers();
          clearLines();

          // 클릭 마커
          const clickedMarker = createMarker(0xffff00);
          clickedMarker.userData = { lat, lng, t: 0 };
          markerGroup.add(clickedMarker);
          markers.push(clickedMarker);
          setMarkerPosition(clickedMarker, lat, lng, 1.02);

          // 안티포드 마커
          const antipodeMarker = createMarker(0xff0000);
          antipodeMarker.userData = { lat: antiLat, lng: antiLng, t: Math.PI };
          markerGroup.add(antipodeMarker);
          markers.push(antipodeMarker);
          setMarkerPosition(antipodeMarker, antiLat, antiLng, 1.02);

          // 선
          lineGroup.add(createAntipodeLine(lat, lng, antiLat, antiLng));

          info.innerHTML =
            `Clicked: ${clickedLoc} (${lat.toFixed(2)}, ${lng.toFixed(2)})<br>` +
            `Antipode: ${antipodeLoc} (${antiLat.toFixed(2)}, ${antiLng.toFixed(2)})`;
        });
    }

    // 클릭 이벤트
    world.onGlobeClick(({ lat, lng }) => showAntipode(lat, lng));

    // 폼 입력 처리
    form.addEventListener('submit', e => {
      e.preventDefault();
      const lat = parseFloat(latInput.value);
      const lng = parseFloat(lngInput.value);
      if (isNaN(lat) || isNaN(lng)) return;
      world.pointOfView({ lat, lng, altitude: 2 });
      showAntipode(lat, lng);
    });
  </script>
</body>
</html>
