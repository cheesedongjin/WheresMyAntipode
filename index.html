<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Where's My Antipode?</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <span id="title">Where's My Antipode?</span>
    <nav><a href="other-sites/addresses.html">Other Sites by Jdeseech</a></nav>
  </header>
  <div id="globe-container">
    <div id="globeViz"></div>
    <div id="info">Click anywhere on the globe to find the antipodal location.</div>
    <form id="coord-form">
      <input type="number" id="lat-input" placeholder="Latitude" step="any" required />
      <input type="number" id="lng-input" placeholder="Longitude" step="any" required />
      <button type="submit">Go</button>
    </form>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.153.0';
    import Globe   from 'https://esm.sh/globe.gl@2.41.1';

    // Globe 초기화
    const world = Globe()(document.getElementById('globeViz'))
      .globeImageUrl('https://unpkg.com/three-globe/example/img/earth-night.jpg')
      .pointOfView({ lat: 0, lng: 0, altitude: 2 });

    // Group to hold marker objects
    const markerGroup = new THREE.Group();
    world.scene().add(markerGroup);
    const markers = [];

    // Group to hold antipode line objects
    const lineGroup = new THREE.Group();
    world.scene().add(lineGroup);

    function createMarker(color) {
      const mat = new THREE.MeshBasicMaterial({ color });
      const cone = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 8), mat);
      cone.position.y = -0.25;
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), mat);
      const group = new THREE.Group();
      group.add(cone);
      group.add(sphere);
      return group;
    }

    function setMarkerPosition(marker, lat, lng, altitude) {
      const radius = world.getGlobeRadius ? world.getGlobeRadius() : 100;
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      const r = radius * altitude;
      marker.position.set(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.cos(phi),
        r * Math.sin(phi) * Math.sin(theta)
      );
      marker.lookAt(0, 0, 0);
    }

    function latLngToVector3(lat, lng, altitude) {
      const radius = world.getGlobeRadius ? world.getGlobeRadius() : 100;
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      const r = radius * altitude;
      return new THREE.Vector3(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.cos(phi),
        r * Math.sin(phi) * Math.sin(theta)
      );
    }

    function createAntipodeLine(lat, lng, antiLat, antiLng) {
      const start = latLngToVector3(lat, lng, 1.01);
      const end = latLngToVector3(antiLat, antiLng, 1.01);
      const center = new THREE.Vector3(0, 0, 0);
      const geometry = new THREE.BufferGeometry().setFromPoints([start, center, end]);
      const material = new THREE.LineDashedMaterial({
        color: 0xffffff,
        dashSize: 2,
        gapSize: 1,
        opacity: 0.5,
        transparent: true
      });
      const line = new THREE.Line(geometry, material);
      line.computeLineDistances();
      return line;
    }

    function clearMarkers() {
      while (markerGroup.children.length) markerGroup.remove(markerGroup.children[0]);
      markers.length = 0;
    }

    function clearLines() {
      while (lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
    }

    function animateMarkers() {
      markers.forEach(m => {
        m.userData.t += 0.02;
        const alt = 1.02 + 0.02 * Math.sin(m.userData.t);
        setMarkerPosition(m, m.userData.lat, m.userData.lng, alt);
        m.rotateZ(0.05);
      });
      requestAnimationFrame(animateMarkers);
    }
    animateMarkers();

    const info = document.getElementById('info');
    const form = document.getElementById('coord-form');
    const latInput = document.getElementById('lat-input');
    const lngInput = document.getElementById('lng-input');

    function reverseGeocode(lat, lng) {
      return fetch(
        `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`
      )
        .then(res => res.json())
        .then(data => {
          const addr = data.address || {};
          return (
            addr.city ||
            addr.town ||
            addr.village ||
            addr.country ||
            'the ocean'
          );
        })
        .catch(() => 'Unknown location');
    }

    function showAntipode(lat, lng) {
      const antiLat = -lat;
      const antiLng = ((lng + 180) % 360) - 180;

      Promise.all([reverseGeocode(lat, lng), reverseGeocode(antiLat, antiLng)])
        .then(([clickedLoc, antipodeLoc]) => {
          clearMarkers();
          clearLines();

          const clickedMarker = createMarker(0xffff00);
          clickedMarker.userData = { lat, lng, t: 0 };
          markerGroup.add(clickedMarker);
          markers.push(clickedMarker);

          const antipodeMarker = createMarker(0xff0000);
          antipodeMarker.userData = { lat: antiLat, lng: antiLng, t: Math.PI };
          markerGroup.add(antipodeMarker);
          markers.push(antipodeMarker);

          setMarkerPosition(clickedMarker, lat, lng, 1.02);
          setMarkerPosition(antipodeMarker, antiLat, antiLng, 1.02);

          const line = createAntipodeLine(lat, lng, antiLat, antiLng);
          lineGroup.add(line);

          info.innerHTML =
            `Clicked: ${clickedLoc} (${lat.toFixed(2)}, ${lng.toFixed(2)})<br>` +
            `Antipode: ${antipodeLoc} (${antiLat.toFixed(2)}, ${antiLng.toFixed(2)})`;
        })
        .catch(() => {
          info.textContent =
            `Coordinates: (${lat.toFixed(2)}, ${lng.toFixed(2)}) → (${antiLat.toFixed(2)}, ${antiLng.toFixed(2)})`;
        });
    }

    // Handle click events
    world.onGlobeClick(({ lat, lng }) => {
      showAntipode(lat, lng);
    });

    form.addEventListener('submit', e => {
      e.preventDefault();
      const lat = parseFloat(latInput.value);
      const lng = parseFloat(lngInput.value);
      if (isNaN(lat) || isNaN(lng)) return;
      world.pointOfView({ lat, lng, altitude: 2 });
      showAntipode(lat, lng);
    });
  </script>
</body>
</html>