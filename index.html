<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Where's My Antipode?</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <span id="title">Where's My Antipode?</span>
    <nav><a href="other-sites/addresses.html">Other Sites by Jdeseech</a></nav>
  </header>
  <div id="globe-container">
    <div id="globeViz"></div>
    <div id="info">Click anywhere on the globe to find the antipodal location.</div>
    <form id="coord-form">
      <input type="number" id="lat-input" placeholder="Latitude" step="any" required />
      <input type="number" id="lng-input" placeholder="Longitude" step="any" required />
      <button type="submit">Go</button>
    </form>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.153.0';
    import Globe from 'https://esm.sh/globe.gl@2.41.1';

    // Globe 초기화
    const world = Globe()(document.getElementById('globeViz'))
      .globeImageUrl('https://unpkg.com/three-globe/example/img/earth-night.jpg')
      .pointOfView({ lat: 0, lng: 0, altitude: 2 });

    // 마커와 선을 담을 그룹
    const markerGroup = new THREE.Group();
    world.scene().add(markerGroup);
    const lineGroup = new THREE.Group();
    world.scene().add(lineGroup);
    const markers = [];

    // 마커 생성 함수
    function createMarker(color) {
      const mat = new THREE.MeshBasicMaterial({ color });

      const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), mat);
      return sphere;
    }

    // (lat,lng,altitude) → {x,y,z} 변환 (three-globe 내장)
    function latLngToVector3(lat, lng, altitude) {
      return world.getCoords(lat, lng, altitude);
    }

    // 마커 위치 설정
    function setMarkerPosition(marker, lat, lng, altitude) {
      const { x, y, z } = world.getCoords(lat, lng, altitude);
      marker.position.set(x, y, z);
      marker.lookAt(0, 0, 0); // Make the marker point away from the center of the globe (i.e., upright)
    }

    // 안티포드 선 생성
    function createAntipodeLine(lat, lng, antiLat, antiLng) {
      // 클릭 지점과 안티포드 마커는 1.01 고도
      const a = world.getCoords(lat,     lng,     0.5);
      const b = world.getCoords(lat,     lng,     0.1); // 표면 바로 위
      const c = world.getCoords(antiLat, antiLng, 0.1);
      const d = world.getCoords(antiLat, antiLng, 0.5);

      const pts = [
        new THREE.Vector3(a.x, a.y, a.z),
        new THREE.Vector3(b.x, b.y, b.z),
        new THREE.Vector3(c.x, c.y, c.z),
        new THREE.Vector3(d.x, d.y, d.z)
      ];

      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const mat  = new THREE.LineDashedMaterial({
        color:       0xffffff,
        dashSize:    1,
        gapSize:     1,
        opacity:     0.5,
        transparent: true
      });

      const line = new THREE.Line(geom, mat);
      line.computeLineDistances();
      return line;
    }

    function clearMarkers() {
      markerGroup.clear();
      markers.length = 0; // Clear the array of animated markers
    }
    function clearLines() {
      lineGroup.clear();
    }

    // 마커 애니메이션
    function animateMarkers() {
      markers.forEach(m => {
        m.userData.t += 0.02; // Increment animation time
        const alt = 0.51 + 0.02 * Math.sin(m.userData.t); // Oscillating altitude for "breathing" effect
        setMarkerPosition(m, m.userData.lat, m.userData.lng, alt);
        m.rotateZ(0.05); // Rotate marker around its Z-axis
      });
      requestAnimationFrame(animateMarkers);
    }
    animateMarkers(); // Start the animation loop

    const info = document.getElementById('info');
    const form = document.getElementById('coord-form');
    const latInput = document.getElementById('lat-input');
    const lngInput = document.getElementById('lng-input');

    // 좌표 → 지명 (OSM)
    function reverseGeocode(lat, lng) {
      return fetch(
        `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`
      )
        .then(res => res.json())
        .then(data => {
          const addr = data.address || {};
          return addr.city || addr.town || addr.village || addr.country || 'the ocean';
        })
        .catch(() => 'Unknown location');
    }

    // 안티포드 표시 (즉시 업데이트 개선)
    function showAntipode(lat, lng) {
      const antiLat = -lat;
      // 경도 반전 계산
      const antiLng = lng >= 0 ? lng - 180 : lng + 180;

      // 기존 마커와 선을 즉시 제거
      clearMarkers();
      clearLines();

      // 클릭된 마커를 즉시 생성 및 추가
      const clickedMarker = createMarker(0xffff00); // Yellow marker for clicked location
      clickedMarker.userData = { lat, lng, t: 0 };
      markerGroup.add(clickedMarker);
      markers.push(clickedMarker);
      setMarkerPosition(clickedMarker, lat, lng, 1.01); // Altitude set to 1.01 for the pin's tip on surface

      // 안티포드 마커를 즉시 생성 및 추가
      const antipodeMarker = createMarker(0xff0000); // Red marker for antipode
      antipodeMarker.userData = { lat: antiLat, lng: antiLng, t: Math.PI }; // Offset animation phase
      markerGroup.add(antipodeMarker);
      markers.push(antipodeMarker);
      setMarkerPosition(antipodeMarker, antiLat, antiLng, 1.01); // Altitude set to 1.01 for the pin's tip on surface

      // 선을 즉시 추가
      lineGroup.add(createAntipodeLine(lat, lng, antiLat, antiLng));

      // 초기 정보 텍스트 (좌표만 표시)
      info.innerHTML =
        `Clicked: (${lat.toFixed(2)}, ${lng.toFixed(2)})<br>` +
        `Antipode: (${antiLat.toFixed(2)}, ${antiLng.toFixed(2)})`;

      // 비동기적으로 지명 정보를 가져와서 정보 텍스트 업데이트
      Promise.all([reverseGeocode(lat, lng), reverseGeocode(antiLat, antiLng)])
        .then(([clickedLoc, antipodeLoc]) => {
          info.innerHTML =
            `Clicked: ${clickedLoc} (${lat.toFixed(2)}, ${lng.toFixed(2)})<br>` +
            `Antipode: ${antipodeLoc} (${antiLat.toFixed(2)}, ${antiLng.toFixed(2)})`;
        })
        .catch(() => {
          // 지오코딩 실패 시 오류 메시지
          info.innerHTML = `Clicked: Unknown location (${lat.toFixed(2)}, ${lng.toFixed(2)})<br>` +
                           `Antipode: Unknown location (${antiLat.toFixed(2)}, ${antiLng.toFixed(2)})`;
        });
    }

    // 클릭 이벤트
    world.onGlobeClick(({ lat, lng }) => showAntipode(lat, lng));

    // 폼 입력 처리
    form.addEventListener('submit', e => {
      e.preventDefault();
      const lat = parseFloat(latInput.value);
      const lng = parseFloat(lngInput.value);
      if (isNaN(lat) || isNaN(lng)) {
        alert('Please enter valid numbers for latitude and longitude.');
        return;
      }
      world.pointOfView({ lat, lng, altitude: 2 }, 700); // Fly to initial view over 700ms
      showAntipode(lat, lng); // Show antipode for the entered coordinates
    });
  </script>
</body>
</html>