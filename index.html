<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D4VPZBZ8T4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-D4VPZBZ8T4');
</script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Where's My Antipode?</title>
  <meta property="og:title" content="Where's My Antipode?">
  <meta property="og:description" content="Find the exact opposite point on Earth">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://cheesedongjin.github.io/CheeseV/">
  <link rel="icon" href="icon.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("sw.js");
      });
    }
  </script>
</head>
<body>
  <header>
    <span id="title">
      <img src="icon.png" alt="Icon">
      Where's My Antipode?
    </span>
    <nav><a href="other-sites/addresses">Other Sites by Jdeseech</a></nav>
  </header>

  <div id="globe-container">
    <div id="globeViz"></div>
  </div>

  <div class="control-panel" id="controlPanel">
    <div class="panel-header" id="panelHeader">
      <div class="panel-title">
        <span>üåç</span>
        <span>Antipode Finder</span>
      </div>
      <button class="toggle-btn" id="toggleBtn">‚ñº</button>
    </div>

    <div class="panel-content">
      <div class="instruction">
        <div class="instruction-title">üåç Find Your Antipode</div>
        <div class="instruction-text">Right-click anywhere on the globe or enter coordinates below</div>
      </div>

      <form id="coord-form">
        <div class="input-group">
          <label for="countryInput">Country</label>
          <input id="countryInput" type="text" list="countriesList" placeholder="Search" />
          <datalist id="countriesList"></datalist>
        </div>
        <div class="input-group">
          <label for="latInput">Latitude</label>
          <input id="latInput" type="number" step="0.01" min="-90" max="90" placeholder="0.00" />
        </div>
        <div class="input-group">
          <label for="lngInput">Longitude</label>
          <input id="lngInput" type="number" step="0.01" min="-180" max="180" placeholder="0.00" />
        </div>
        <button type="submit">üîç Find Antipode</button>
      </form>

      <div id="info" style="display: none;">
        <div class="result-info">
          <div class="location-card">
            <div class="location-title">üìç Clicked Location</div>
            <div class="location-name" id="clicked-name">Loading...</div>
            <div class="location-coords" id="clicked-coords"></div>
          </div>
          <div class="location-card antipode">
            <div class="location-title">üåè Antipode</div>
            <div class="location-name" id="antipode-name">Loading...</div>
            <div class="location-coords" id="antipode-coords"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.153.0';
    import Globe from 'https://esm.sh/globe.gl@2.41.1';
    import * as turf from 'https://esm.sh/@turf/turf@6';

    function ringArea(r) {
      let a = 0;
      for (let i = 0; i < r.length - 1; i++) {
        const [x1, y1] = r[i];
        const [x2, y2] = r[i + 1];
        a += (x2 - x1) * (y2 + y1);
      }
      return a;
    }

    function fixOrientation(f) {
      const t = f.geometry.type;
      const cs = f.geometry.coordinates;
      const eachRing = (ring, idx) => {
        const a = ringArea(ring);
        if ((idx === 0 && a < 0) || (idx > 0 && a > 0)) ring.reverse();
      };
      if (t === 'Polygon') {
        cs.forEach(eachRing);
      } else if (t === 'MultiPolygon') {
        cs.forEach(p => p.forEach(eachRing));
      }
    }

    const countriesDataPromise = fetch('countries.geojson')
      .then(res => res.json())
      .then(data => {
        data.features.forEach(fixOrientation);
        return data;
      });

    const countryCentersPromise = (async () => {
      const cached = localStorage.getItem('countryCenters');
      if (cached) return JSON.parse(cached);
      const data = await countriesDataPromise;
      const centers = {};
      data.features.forEach(f => {
        const c = turf.centroid(f);
        centers[f.properties.NAME] = c.geometry.coordinates;
      });
      localStorage.setItem('countryCenters', JSON.stringify(centers));
      return centers;
    })();

    // Ìå®ÎÑê ÌÜ†Í∏Ä Ìï®Ïàò
    function togglePanel() {
      const panel = document.getElementById('controlPanel');
      const toggleBtn = document.getElementById('toggleBtn');

      panel.classList.toggle('collapsed');
      toggleBtn.textContent = panel.classList.contains('collapsed') ? '‚ñ≤' : '‚ñº';
    }

    // Attach event listener to the panel header
    document.getElementById('panelHeader').addEventListener('click', togglePanel);togglePanel = togglePanel;

    // Globe Ï¥àÍ∏∞Ìôî
    const world = Globe()(document.getElementById('globeViz'))
      .globeImageUrl('https://unpkg.com/three-globe/example/img/earth-night.jpg')
      .pointOfView({ lat: 0, lng: 0, altitude: 2 })
      .backgroundColor('rgba(0,0,0,0)');

    // countries highlight layer
    const highlightedCountries = [];
    world.polygonsData(highlightedCountries)
      .polygonAltitude(0.01)
      .polygonCapColor(d => d.properties._role === 'start'
        ? 'rgba(245,158,11,0.5)'
        : 'rgba(239,68,68,0.5)')
      .polygonSideColor(() => 'rgba(255,255,255,0.15)')
      .polygonStrokeColor(d => d.properties._role === 'start'
        ? '#f59e0b'
        : '#ef4444');

    // Collapse panel when the user interacts with the globe
    world.controls().addEventListener('start', () => {
      const panel = document.getElementById('controlPanel');
      if (!panel.classList.contains('collapsed')) {
        togglePanel();
      }
    });

    // ÎßàÏª§ÏôÄ ÏÑ†ÏùÑ Îã¥ÏùÑ Í∑∏Î£π
    const markerGroup = new THREE.Group();
    world.scene().add(markerGroup);
    const lineGroup = new THREE.Group();
    world.scene().add(lineGroup);
    const markers = [];

    // ÎßàÏª§ ÏÉùÏÑ± Ìï®Ïàò (Í∞úÏÑ†Îêú ÎîîÏûêÏù∏)
    function createMarker(color, isAntipode = false) {
      const mat = new THREE.MeshPhongMaterial({
        color,
        shininess: 100,
        transparent: true,
        opacity: 0.9
      });

      const sphere = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), mat);

      // Í∏ÄÎ°úÏö∞ Ìö®Í≥º
      const glowMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.3
      });
      const glowSphere = new THREE.Mesh(new THREE.SphereGeometry(2.5, 16, 16), glowMat);

      sphere.add(glowSphere);
      return sphere;
    }

    function setMarkerPosition(marker, lat, lng, altitude) {
      const { x, y, z } = world.getCoords(lat, lng, altitude);
      marker.position.set(x, y, z);
      marker.lookAt(0, 0, 0);
    }

    // Í∞úÏÑ†Îêú ÏïàÌã∞Ìè¨Îìú ÏÑ†
    function createAntipodeLine(lat, lng, antiLat, antiLng) {
      const a = world.getCoords(lat, lng, 0.5);
      const b = world.getCoords(lat, lng, 0.1);
      const c = world.getCoords(antiLat, antiLng, 0.1);
      const d = world.getCoords(antiLat, antiLng, 0.5);

      const pts = [
        new THREE.Vector3(a.x, a.y, a.z),
        new THREE.Vector3(b.x, b.y, b.z),
        new THREE.Vector3(c.x, c.y, c.z),
        new THREE.Vector3(d.x, d.y, d.z)
      ];

      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineDashedMaterial({
        color: 0x4f46e5,
        dashSize: 2,
        gapSize: 1,
        opacity: 0.8,
        transparent: true,
        linewidth: 2
      });

      const line = new THREE.Line(geom, mat);
      line.computeLineDistances();
      return line;
    }

    function clearMarkers() {
      markerGroup.clear();
      markers.length = 0;
    }

    function clearLines() {
      lineGroup.clear();
    }

    // Í∞úÏÑ†Îêú ÎßàÏª§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    function animateMarkers() {
      markers.forEach(m => {
        m.userData.t += 0.015;
        const alt = 0.51 + 0.03 * Math.sin(m.userData.t);
        setMarkerPosition(m, m.userData.lat, m.userData.lng, alt);
        m.rotateY(0.02);

        // Í∏ÄÎ°úÏö∞ Ìö®Í≥º Ïï†ÎãàÎ©îÏù¥ÏÖò
        if (m.children[0]) {
          m.children[0].material.opacity = 0.2 + 0.1 * Math.sin(m.userData.t * 2);
        }
      });
      requestAnimationFrame(animateMarkers);
    }
    animateMarkers();

    const info = document.getElementById('info');
    const form = document.getElementById('coord-form');
    const latInput = document.getElementById('latInput');
    const lngInput = document.getElementById('lngInput');
    const countryInput = document.getElementById('countryInput');

    countryCentersPromise.then(cs => {
      const list = document.getElementById('countriesList');
      Object.keys(cs).sort().forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        list.appendChild(opt);
      });
    });

    countryInput.addEventListener('change', () => {
      const name = countryInput.value.trim();
      countryCentersPromise.then(cs => {
        if (!cs[name]) {
          showNotification('Country not found', 'error');
          return;
        }
        const [lng, lat] = cs[name];
        latInput.value = lat.toFixed(2);
        lngInput.value = lng.toFixed(2);
        showAntipode(lat, lng);
      });
    });

    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const lat = parseFloat(latInput.value);
      const lng = parseFloat(lngInput.value);
      if (isNaN(lat) || isNaN(lng)) {
        showNotification('Please enter valid coordinates', 'error');
        return;
      }
      showAntipode(lat, lng);
    });

    // ÏïåÎ¶º ÌëúÏãú
    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `success-message ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);

      setTimeout(() => notification.classList.add('show'), 100);
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    // countries.geojson ÏùÑ Ïù¥Ïö©Ìïú ÏßÄÏó≠ Ï∂îÏ∂ú
    async function reverseGeocode(lat, lng) {
      try {
        const data = await countriesDataPromise;
        const pt = turf.point([lng, lat]);
        const country = data.features.find(f => turf.booleanPointInPolygon(pt, f));
        return country ? country.properties.NAME : 'Ocean';
      } catch (e) {
        return 'Unknown location';
      }
    }

    const NEAR_THRESHOLD_KM = 200;

    async function nearestCountry(lat, lng, threshold = NEAR_THRESHOLD_KM) {
      const data = await countriesDataPromise;
      const pt = turf.point([lng, lat]);
      let min = Infinity;
      let nearest = null;
      data.features.forEach(f => {
        const line = turf.polygonToLine(f);
        const dist = turf.pointToLineDistance(pt, line, { units: 'kilometers' });
        if (dist < min) {
          min = dist;
          nearest = f.properties.NAME;
        }
      });
      return min <= threshold ? nearest : null;
    }

    async function getCountryFeature(lat, lng) {
      try {
        const data = await countriesDataPromise;
        const pt = turf.point([lng, lat]);
        return data.features.find(f => turf.booleanPointInPolygon(pt, f));
      } catch (e) {
        return null;
      }
    }

    // Í∞úÏÑ†Îêú ÏïàÌã∞Ìè¨Îìú ÌëúÏãú
    function showAntipode(lat, lng) {
      const antiLat = -lat;
      const antiLng = lng >= 0 ? lng - 180 : lng + 180;

      clearMarkers();
      clearLines();
      highlightedCountries.length = 0;
      world.polygonsData(highlightedCountries);

      // ÎßàÏª§ ÏÉùÏÑ±
      const clickedMarker = createMarker(0xf59e0b, false);
      clickedMarker.userData = { lat, lng, t: 0 };
      markerGroup.add(clickedMarker);
      markers.push(clickedMarker);
      setMarkerPosition(clickedMarker, lat, lng, 1.01);

      const antipodeMarker = createMarker(0xef4444, true);
      antipodeMarker.userData = { lat: antiLat, lng: antiLng, t: Math.PI };
      markerGroup.add(antipodeMarker);
      markers.push(antipodeMarker);
      setMarkerPosition(antipodeMarker, antiLat, antiLng, 1.01);

      lineGroup.add(createAntipodeLine(lat, lng, antiLat, antiLng));

      Promise.all([
        getCountryFeature(lat, lng),
        getCountryFeature(antiLat, antiLng)
      ]).then(([startF, antiF]) => {
        if (startF) {
          const c = JSON.parse(JSON.stringify(startF));
          c.properties._role = 'start';
          highlightedCountries.push(c);
        }
        if (antiF) {
          const c = JSON.parse(JSON.stringify(antiF));
          c.properties._role = 'antipode';
          highlightedCountries.push(c);
        }
        world.polygonsData(highlightedCountries);
      });

      // UI ÏóÖÎç∞Ïù¥Ìä∏
      info.style.display = 'block';
      document.getElementById('clicked-coords').textContent = `${lat.toFixed(4)}, ${lng.toFixed(4)}`;
      document.getElementById('antipode-coords').textContent = `${antiLat.toFixed(4)}, ${antiLng.toFixed(4)}`;

      // Î°úÎî© ÏÉÅÌÉú
      document.getElementById('clicked-name').textContent = 'Loading...';
      document.getElementById('antipode-name').textContent = 'Loading...';
      document.getElementById('clicked-name').classList.add('loading');
      document.getElementById('antipode-name').classList.add('loading');

      // ÏßÄÎ™Ö Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
      Promise.all([reverseGeocode(lat, lng), reverseGeocode(antiLat, antiLng)])
        .then(async results => {
          let [clickedLoc, antipodeLoc] = results;
          if (clickedLoc === 'Ocean') {
            const near = await nearestCountry(lat, lng);
            if (near) clickedLoc = `Ocean (near ${near})`;
          }
          if (antipodeLoc === 'Ocean') {
            const near = await nearestCountry(antiLat, antiLng);
            if (near) antipodeLoc = `Ocean (near ${near})`;
          }
          document.getElementById('clicked-name').textContent = clickedLoc;
          document.getElementById('antipode-name').textContent = antipodeLoc;
          document.getElementById('clicked-name').classList.remove('loading');
          document.getElementById('antipode-name').classList.remove('loading');
        })
        .catch(() => {
          document.getElementById('clicked-name').textContent = 'Unknown location';
          document.getElementById('antipode-name').textContent = 'Unknown location';
          document.getElementById('clicked-name').classList.remove('loading');
          document.getElementById('antipode-name').classList.remove('loading');
        });

      world.pointOfView({ lat: antiLat, lng: antiLng, altitude: 2 }, 700);
      showNotification('Antipode found! üåç');

      // Ìå®ÎÑêÏù¥ Ï†ëÌòÄÏûàÎã§Î©¥ ÏûêÎèôÏúºÎ°ú ÌéºÏπòÍ∏∞
      const panel = document.getElementById('controlPanel');
      if (panel.classList.contains('collapsed')) {
        togglePanel();
      }
    }

    world.onGlobeRightClick(({ lat, lng }) => {
      showAntipode(lat, lng);
    });
  </script>
</body>
</html>